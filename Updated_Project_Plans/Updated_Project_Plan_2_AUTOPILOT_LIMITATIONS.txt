Current design spec for Autopilot / Blueprint / Learning & ingestion phases as of 2025-12-09.
Implementation status is tracked in docs/REQUIREMENTS_CRM.md, docs/TODO_CHECKLIST.md, and docs/PROGRESS.md. Autopilot remains design-only; these documents are roadmap/spec, not shipped behavior.

This file explains what the InfinityWindow autopilot manager + workers system will and will not do.
Treat this as the contract for humans, future devs, and AI agents when using or extending autopilot.

Autopilot is designed to behave like a careful project manager and dev team working inside a single InfinityWindow project – not as an unconstrained, self‑modifying AI.

API_REFERENCE

1. Scope & mental model

Autopilot consists of:

A Manager agent that:

Reads the project Blueprint/Plan/Tasks/Decisions/Snapshot.

Chooses what to work on next.

Starts and advances ExecutionRuns.

One or more Worker agents that:

Read/write files under the project root.

Run safe terminal commands/tests.

Update docs and tasks.

The system is optimized for incremental, test‑driven work on a single codebase / project, over days or months – not for arbitrary internet actions, shell automation over your whole machine, or fully unsupervised “build me anything” behavior.

API_REFERENCE

2. Hard technical limits
2.1 Context & token limits

Each LLM call (chat, worker, manager, research) has a finite context window.

The project can have:

Huge blueprints (hundreds of thousands of words).

Large repos with thousands of files.

Long conversations spanning months.

Autopilot never sees “everything at once”:

It works on chunked views of docs and code.

It relies on search + summaries + snapshots to stay aligned.

It can miss details that are only mentioned once in a forgotten corner of the project.

Design implication: Important constraints must be surfaced in:

Project instructions (Notes tab).

Decision log entries.

Memory items.

The Blueprint/Plan hierarchy.

API_REFERENCE

2.2 Embedding & ingestion limits

Repo and blueprint ingestion are batched to respect provider limits (e.g. ~300k tokens per embeddings request).

Very large repos/specs may require multiple ingestion passes.

Ingestion may skip:

Binaries.

Extremely large individual files.

Files excluded by globs.

Autopilot can only reason over what has been successfully ingested and indexed. If a file or doc was never ingested (or failed ingestion), it will not show up in search or plan derivation.

2.3 Single‑project scope

File and terminal tools are restricted to a project’s local_root_path.

API_REFERENCE

Autopilot cannot:

Touch files outside the root.

Run commands outside the root (no cwd escape, no .. hacks).

Work across multiple projects in the same run.

If you need autopilot across multiple repos, you must create multiple projects and coordinate manually.

2.4 No true background daemons (yet)

Autopilot progresses via /projects/{id}/autopilot_tick, which is called on a timer by the frontend while a project is open.

When:

The UI is closed,

Or the user switches projects,

Or the server is stopped,
autopilot is idle – no background jobs are running.

This is a deliberate design choice so that all autopilot activity is anchored to an open session and visible to the user.

3. Safety & guardrails

Autopilot is not allowed to do everything a human can do. It operates under explicit safety rules.

3.1 Filesystem safety

All paths are normalized and checked against local_root_path.

Attempts to escape (.., absolute paths, different drives) are rejected.

File edits are:

Logged as ExecutionStep records.

Linked to an ExecutionRun.

Associated with pre‑ and post‑content so they can be diffed and rolled back.

3.2 Terminal safety

Autopilot respects a command allowlist:

Auto‑execution (semi/full‑auto) is limited to clearly safe commands, e.g.:

pytest ...

npm test

npm run build

python -m qa.run_smoke

Linting commands

Commands that are never auto‑run:

rm, del, format, shutdown, reboot, etc.

git push, git reset, git clean, and other destructive Git ops.

Any command that does not match the configured “safe prefixes”.

These commands can still be run manually by a human in the Terminal tab; autopilot will not execute them on its own.

Presentation_Outline

3.3 Approval gates

Depending on autonomy mode:

Off – Manager does nothing automatically.

Suggest – Manager proposes runs and steps; all file edits and commands require explicit approval.

Semi auto:

Autopilot can auto‑run safe reads/searches/tests.

File writes and unsafe commands require explicit approval.

Full auto:

Autopilot may auto‑run file edits and safe commands.

Still never runs forbidden commands.

All writes maintain rollback data so the entire run can be reverted.

Humans stay in final control of critical changes.

4. Behavioral limitations
4.1 Autopilot depends on a good plan

The manager is only as good as the plan it sees:

If the Blueprint is incomplete or vague, PlanNodes and tasks will be incomplete or vague.

If tasks are missing acceptance criteria, workers may implement the wrong thing.

If decisions are not captured, autopilot may repeat old discussions or undo past choices.

Autopilot does not magically infer your true intent from a single sentence; it reinforces whatever is encoded in:

Blueprint / Plan hierarchy.

Tasks and their metadata.

Instructions / Decisions / Memory.

4.2 Tests are just another artifact

Autopilot treats tests as:

Files it can read, write, and run.

Primary source of “are we done?” for a run.

But it cannot guarantee:

That tests exist for a given behavior.

That tests themselves are correct.

That passing tests mean the feature is production‑ready.

If tests are missing or weak, full‑auto behavior is dangerous. Humans are expected to:

Seed at least minimal tests.

Review test diffs for dangerous changes.

4.3 Non‑determinism and drift

LLMs are probabilistic; two runs on the same task may produce slightly different plans or code.

Manager heuristics may change over time as the project grows.

A long series of autopilot changes can drift from the original blueprint if:

Requirements change but the blueprint is not updated.

Humans approve “quick hacks” that contradict earlier decisions.

InfinityWindow mitigates this with:

Conversation summaries.

Project snapshots.

Decision log.

PlanNode/task linkage.

…but it cannot guarantee that the system never goes off‑track; humans must occasionally step back, review the snapshot/plan, and realign.

API_REFERENCE

5. Operational expectations (what humans must still do)

Even in full‑auto mode, the human “CEO” / operator is responsible for:

Initial project setup

Correct local_root_path.

Required environment variables, secrets, API keys.

Basic tests and CI wired.

Blueprint quality

Uploading a good blueprint (or iterating it).

Approving the generated PlanNodes and tasks.

Setting autonomy

Choosing off / suggest / semi / full per project and adjusting as trust grows.

Reviewing diffs and commands

Spot‑checking code changes.

Reviewing dangerous commands.

Using “Revert run” when needed.

Running higher‑level QA

qa/run_smoke.py for backend.

npm run build + Playwright tests for frontend.

Following TEST_PLAN.md for major releases.

OPERATIONS_RUNBOOK

Autopilot is a force multiplier, not a replacement for engineering judgment or proper QA.

6. Known “hard” non‑goals

Autopilot is not intended to:

Manage multiple disjoint projects in one brain.

Perform arbitrary internet automation (scraping, logging into websites, etc.).

Replace your CI system or deployment pipeline.

Guarantee correctness, security, or compliance.

Operate unattended for weeks without human review.

Self‑modify InfinityWindow’s own core logic without explicit human intent.

If you want any of these, treat them as separate projects that build on top of InfinityWindow rather than hidden features of autopilot.

7. Extending or changing limitations

When extending autopilot, you must:

Update this file whenever:

A new autonomy mode is introduced.

Safe command rules change.

Cross‑project behavior is added.

Update:

SYSTEM_MATRIX.md (models, endpoints, UI surfaces).

AGENT_GUIDE

AGENT_GUIDE.md (safe operations for AI agents).

Presentation_Outline

SECURITY_PRIVACY.md if security implications change.

Treat AUTOPILOT_LIMITATIONS.md as the source of truth for what autopilot is allowed to do.